class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        const int N = graph.size();
        
        // mark the infection sources (i.e., nodes from the initial vector)
        vector<bool> is_infection_src(N, false);
        for(int initial_node: initial){
            is_infection_src[initial_node] = true;
        }
        
        // valid partial connected component (vpcc): connected component of a graph
        //                                           which contains a single infection source
        // infection_capacity[infection_src]: the size of all vpccs that contain the infection_src
        vector<int> infection_capacity(N, 1);
        vector<bool> vis(N, false);
        for(int current_node = 0; current_node < N; ++current_node){
            if(!vis[current_node] && !is_infection_src[current_node]){
                vector<int> vpcc_infection_sources;
                int vpcc_size = 0;
                queue<int> q;
                q.push(current_node);
                vis[current_node] = true;
                while(!q.empty()){
                    int node = q.front();
                    q.pop();
                    vpcc_size += 1;
                    for(int next_node = 0; next_node < N; ++next_node){
                        if(graph[node][next_node] && !vis[next_node]){
                            if(is_infection_src[next_node]){
                                if(vpcc_infection_sources.size() <= 1){
                                    vpcc_infection_sources.push_back(next_node);
                                }
                            }else{
                                q.push(next_node);
                                vis[next_node] = true;
                            }
                        }
                    }
                }
                if(vpcc_infection_sources.size() == 1){
                    infection_capacity[vpcc_infection_sources[0]] += vpcc_size;
                }
            }
        }
        
        // select the node with the maximum infection_capacity
        // in case of a tie return the node with the minimum index
        int answer = initial[0];
        for(int initial_node: initial){
            if(infection_capacity[initial_node] > infection_capacity[answer]){
                answer = initial_node;
            }else if(infection_capacity[initial_node] == infection_capacity[answer] && initial_node < answer){
                answer = initial_node;
            }
        }
        
        return answer;
    }
};