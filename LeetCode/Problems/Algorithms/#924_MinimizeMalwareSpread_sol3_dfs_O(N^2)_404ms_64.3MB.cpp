class Solution {
private:
    void dfs(int node, int color, vector<int>& colors, vector<vector<int>>& graph){
        colors[node] = color;
        for(int next_node = 0; next_node < graph.size(); ++next_node){
            if(graph[node][next_node] && colors[next_node] == -1){
                dfs(next_node, color, colors, graph);
            }
        }
    }
    
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        const int N = graph.size();
        vector<int> colors(N, -1);
        int color = -1;
        for(int node = 0; node < N; ++node){
            if(colors[node] == -1){
                color += 1;
                dfs(node, color, colors, graph);
            }
        }
        
        vector<int> size(color + 1, 0);
        for(int c: colors){
            size[c] += 1;
        }
        
        vector<int> color_cnt(color + 1, 0);
        for(int node: initial){
            color_cnt[colors[node]] += 1;
        }
        
        int answer = N;
        for(int node: initial){
            int c = colors[node];
            if(color_cnt[c] == 1){
                if(answer == N){
                    answer = node;
                }else if(size[c] > size[colors[answer]] || (size[c] == size[colors[answer]] && node < answer)){
                    answer = node;
                }
            }
        }
        
        if(answer == N){
            answer = *min_element(initial.begin(), initial.end());
        }
        
        return answer;
    }
};