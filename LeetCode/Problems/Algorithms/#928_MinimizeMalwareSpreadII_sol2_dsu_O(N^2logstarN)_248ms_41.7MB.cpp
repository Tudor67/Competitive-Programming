class DSU{
private:
    vector<int> parent;
    vector<int> rank;
    vector<int> size;
    
public:
    DSU(const int& N){
        size.resize(N + 1, 1);
        rank.resize(N + 1, 0);
        parent.resize(N + 1);
        iota(parent.begin(), parent.end(), 0);
    }
    
    int find(int x){
        if(x != parent[x]){
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }
    
    void join(int x, int y){
        int x_root = find(x);
        int y_root = find(y);
        if(x_root != y_root){
            if(rank[x_root] <= rank[y_root]){
                parent[x_root] = y_root;
                size[y_root] += size[x_root];
            }else{
                parent[y_root] = x_root;
                size[x_root] += size[y_root];
            }
            if(rank[x_root] == rank[y_root]){
                rank[y_root] += 1;
            }
        }
    }
    
    int get_size(int x){
        return size[find(x)];
    }
};

class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        const int N = graph.size();
        
        vector<bool> is_healthy(N, true);
        for(int infection_src: initial){
            is_healthy[infection_src] = false;
        }
        
        DSU dsu(N);
        for(int node1 = 0; node1 < N; ++node1){
            for(int node2 = node1 + 1; node2 < N; ++node2){
                if(graph[node1][node2] && is_healthy[node1] && is_healthy[node2]){
                    dsu.join(node1, node2);
                }
            }
        }
        
        vector<vector<int>> infection_sources_of(N);
        for(int infection_src: initial){
            for(int node = 0; node < N; ++node){
                if(node != infection_src && is_healthy[node] && graph[infection_src][node]){
                    int node_root = dsu.find(node);
                    if(infection_sources_of[node_root].size() <= 1){
                        infection_sources_of[node_root].push_back(infection_src);
                    }
                }
            }
        }
        
        vector<int> infection_capacity(N);
        for(int node_root = 0; node_root < N; ++node_root){
            if(infection_sources_of[node_root].size() == 1){
                infection_capacity[infection_sources_of[node_root][0]] += dsu.get_size(node_root);
            }
        }
        
        int answer = initial[0];
        for(int infection_src: initial){
            if(infection_capacity[infection_src] > infection_capacity[answer]){
                answer = infection_src;
            }else if(infection_capacity[infection_src] == infection_capacity[answer] && infection_src < answer){
                answer = infection_src;
            }
        }
        
        return answer;
    }
};